일반적인 Sequential한 (배열) 정렬 예시...

    stable-sort <- merge sort...  
    unstable-sort <- quick sort...

간단한 병렬 (배열) 정렬 아이디어 (Divide, Partial? Sort, Merge)

    1. 배열을 M개의 구역으로 나눈다. (Divide)
    2. 나눠진 각각의 배열을 동시에(parallel) 기존의 sequential한 정렬 방법을 사용하여 정렬한다. (Partial? Sort)
    3. winner tree? 등을 이용해 각각의 정렬된 배열을 전체 정렬된 배열으로 만든다. (Merge?)
    
위의 아이디어 Divide, Partial? Sort, Merge는 병렬 스캐닝 및 병렬 파싱에도 이용된다.
                                                                    
다만 스캐닝에 병렬 아이디어를 이용하기에는 성능이 좋지 않은 것 같다. (아니면 더 많은 cpu코어가 필요한 것 같다.)

json 문법 -> 특정 문법으로 바꾸어 json을 처리한 내용을 앞으로 보게 될 것이다.

 여기서 말하는 특정 문법은 병렬(using thread) 파싱을 하기가 용이한 것 같다. 다만, 쉬운 이해 및 구현?을 위해서는

파싱하는 json이 valid하다는 가정이 필요하다.?

토큰들로부터 트리형태(DOM?)를 만들기 전에 토큰 위치에서의 state값을 알 필요가 있다. 

일반적으로 json 같은 경우 state값의 범위가 여러 개 이상이다. (예외처리도 하기떄문에 더 커지는 것 같다.?) 

이런 경우 토큰들을 Divide했을떄, state값을 추정하기가 어렵다.  아니면 Divide하는데 시간이 많이 필요로 할지도 모른다.

하지만 json이 valid한다고 가정하고, json를 받아 들이는 문법을 더 넓은 언어도 받아들이는 앞으로 이야기할 특정한 문법으로 바꾼다. 

그러면, 어느 토큰 위치에서나 state값이 한가지로 같게 만들 수 있다. 즉 Divide를 사실상 거의 아무렇게나 할 수 있다 그것도 상수타임?에.

하지만 이제 Partial Parsing과 Merge가 여전히 문제로 남아있다.

    count 초기값은 0이다.

    { 나 [ 를 만나면 count를 +1를 하고 } 나 ] 를 만나면 count를 -1를 한다고 생각해보자

거의 아무렇게나 Divide를 하게되면... 나눠진 토큰 블록마다 count값이 양수 이거나 0 이거나 음수 가 되게 된다.

그리고 valid한 json문장이라면 count는 0이어야 한다.

즉 아무렇게나 Divide를 했을 떄, 불완전한 json 부분이 생기므로 이를 해결해야한다.

이를 해결하기위해서 가상의 노드(Virtual Node) 라는 개념을 사용하였다.

일단 Node란 json에서 Array나 Object를 말한다.

다음과 같은 valid하지않은 json 문장이 있다고 생각하자.

     3, 4, 5]
 
그러면 [가 없지만 있다고 생각하고 Node를 만들되, 완성된것은 아니므로 Virtual 이라는 이름을 붙였다.

    # = [ 3, 4, 5 ] // # = [ 는 virtual node임을 나타내기 위해 붙인 것이다.
  
부분 파싱 과정에서 자료구조 스택(stack)를 이용하여 나눠진 부분을 표시할 수 있다.

그리고 virtual node의 특성을 이용하면 쉽게 Merge를 할 수 있게 된다.

구체적인 방법(및 C++ 코드) 과 구체적인 여러번 언급한 문법에 대해서는 추후에 알아볼 것이다.

